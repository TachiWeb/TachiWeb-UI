<!-- Object watching API, allows seamless data sync across tabs and information sharing between components -->
<link rel="import" href="/bower_components/polymer/polymer.html">

<!--
Watches a single object.
Updates to the object are propapagted across all tabs in the browser and all components in each tab.
Updates are debounced.

Requires each object to have an ID. Objects should be grouped by type.
-->
<dom-module id="watch-object">
  <template>
    </template>

  <script>
    Polymer({
      is: 'watch-object',

      properties: {
        object: {
          type: Object,
          notify: true,
          observer: '_objChanged'
        },
        type: {
          type: String,
          notify: true
        },
        id: {
          type: Object,
          notify: true,
          value: 0
        },
        eventHubName: {
          type: String,
          value: 'ObjectEvent'
        },
        lastUpdateTime: {
          type: Number,
          value: 0
        },
        internalOnly: {
          type: Boolean,
          value: false
        },
        disableSetter: {
          type: Boolean,
          value: false
        }
      },

      observers: [
        '_watchObj(type, id)'
      ],

      _watchObj: function(type, id) {
        let that = this;
        //Disconnect current event hub
        if (this.connection !== null && this.connection !== undefined) {
          this.connection.disconnect();
          this.connection = null;
        }
        //Create new connection
        this.connection = EventHub.connect();
        //Listen for object changes
        this.connection.on(this.eventHubName, function(data, internal) {
          if(that.disableSetter
            || (that.internalOnly && !internal)) return; //Reject external data if we are internal only
          //Check both ID and type are the same
          if (data.object !== undefined && data.object !== null
                             && data.type === type && data.id === id) {
            if (data.timestamp > that.lastUpdateTime) {
              //Prevent broadcasting our own changes!
              //Assign signature if we don't have one yet
              if(data.object._nextChangeSignature === null || data.object._nextChangeSignature === undefined) {
                data.object._nextChangeSignature = Util.guid();
              }
              //Update our signature
              that.nextChangeSignature = data.object._nextChangeSignature;
             that.object = data.object;
            }
          }
        });
        this.connection.on("ObjectRequest", function(requestedType, internal) {
          if(that.internalOnly && !internal) return; //Reject external data if we are internal only
          if(requestedType === that.type) {
            //Generate a new object signature
            that.nextChangeSignature = Util.guid();
            //Broadcast fake change
            that._objChanged();
          }
        });
      },

      _objChanged: function() {
        if(this.object === undefined || this.object === null) {
          return;
        }
        //Do not broadcast our own changes!
        if(this.object._nextChangeSignature !== null && this.object._nextChangeSignature !== undefined) {
          //Signature matches local one, do not broadcast
          if(this.object._nextChangeSignature === this.nextChangeSignature) {
            //Assign new signature so next change will be broadcast
            this.nextChangeSignature = Util.guid();
            return;
          }
        } else {
          //No signature means the object came from an outside source (so we should broadcast it)
          //We still assign it a signature.
          //When assigning the signature, since it matches the local signature, the signature change event will not be broadcast
          this.nextChangeSignature = Util.guid();
          this.object._nextChangeSignature = this.nextChangeSignature;
        }
        this.lastUpdateTime = Date.now();
        if (this.debounceFunc === null || this.debounceFunc === undefined) {
          let that = this;
          this.debounceFunc = Util.debounce(function() {
            EventHub.emit(that.eventHubName, {
              type: that.type,
              id: that.id,
              object: that.object,
              timestamp: that.lastUpdateTime
            }, that.internalOnly);
          }, 50);
        }
        this.debounceFunc();
      },
      
      //Request all nodes with data on this object type to transmit it
      requestData: function() {
        EventHub.emit("ObjectRequest", this.type);
      }
    });
  </script>
</dom-module>

<!--
Watch for objects that match a certain filter.
Changes to object that match the filter in any component in any window will automatically add/remove the object from the array based on whether or not the object matches the filter.
Requires objects store their ID in a parameter.
Do not add/remove objects from the array.
Only matches objects that match it's type.
-->
<dom-module id="watch-object-filter">
  <template>
    <template is="dom-repeat" items="[[filtered]]">
        <watch-object object="{{item}}" type="[[type]]" id="[[_arraySelector(item, idParam)]]" internal-only="[[internalOnly]]" disable-setter></watch-object>
    </template>
  </template>

  <script>
    Polymer({
      is: 'watch-object-filter',

      properties: {
        filtered: {
          type: Array,
          value: [],
          notify: true
        },
        type: {
          type: String,
          notify: true
        },
        filter: {
          type: Object,
          notify: true
        },
        idParam: {
          type: String,
          notify: true
        },
        eventHubName: {
          type: String,
          value: 'ObjectEvent'
        },
        internalOnly: {
          type: Boolean,
          value: false
        }
      },

      observers: [
        '_watchFilter(type, filter, idParam)'
      ],

      _watchFilter: function(type, filter, idParam) {
        let that = this;
        //Disconnect current event hub
        if (this.connection !== null && this.connection !== undefined) {
          this.connection.disconnect();
          this.connection = null;
        }
        //Create new connection
        this.connection = EventHub.connect();

        let filterFunction = Function.from(filter);

        //Listen for object changes
        this.connection.on(this.eventHubName, function(data) {
          //Check that we care about this type
          if (data.type === type && data.object !== undefined && data.object != null) {
            //Check with filter
            let valid = filterFunction(data.object);
            //Get object id
            let id = data.object[idParam];

            if (valid) {
              //Add to array if valid and not already in array
              for (let i = 0; i < that.get("filtered").length; i++) {
                if (that.get(["filtered", i, idParam]) === id) {
                  //Found the same object, just apply the changes
                  if(that.get(["filtered", i, "_nextChangeSignature"]) !== data.object._nextChangeSignature) {
                    that.set(["filtered", i], data.object);
                  }
                  return;
                }
              }
              that.push('filtered', data.object);
            }
            else {
              //Remove from array
              //Iterate through array and find existing object
              for (let i = 0; i < that.get("filtered").length; i++) {
                if (that.get(["filtered", i, idParam]) === id) {
                  that.splice("filtered", i, 1);
                }
              }
            }
          }
        });
      },
      
      //Used for selecting idParam
      _arraySelector: function(array, index) {
        return array[index];
      },
      
      //Request all nodes with data on this object type to transmit it
      requestData: function() {
        EventHub.emit("ObjectRequest", this.type);
      }
    });
  </script>
</dom-module>

<!--
Similar to watch-object-filter except there is no filter.
Every object event noticed by the watch-object-frozen element is kept in it's memory forever.
It will respond to requests for objects.
It's externally visible array serves simply as input, it will not make any changes to it.
-->
<dom-module id="watch-object-frozen">
  <template>
    <template is="dom-repeat" items="[[_internalArray]]">
        <watch-object object="{{item}}" type="[[type]]" id="[[_arraySelector(item, idParam)]]" internal-only="[[internalOnly]]" disable-setter></watch-object>
    </template>
    <template is="dom-repeat" items="[[array]]">
        <watch-object object="{{item}}" type="[[type]]" id="[[_arraySelector(item, idParam)]]" internal-only="[[internalOnly]]" disable-setter></watch-object>
    </template>
  </template>

  <script>
    Polymer({
      is: 'watch-object-frozen',

      properties: {
        array: {
          type: Array,
          value: [],
          notify: true
        },
        _internalArray: {
          type: Array,
          value: [],
          notify: true
        },
        type: {
          type: String,
          notify: true
        },
        idParam: {
          type: String,
          notify: true
        },
        eventHubName: {
          type: String,
          value: 'ObjectEvent'
        },
        internalOnly: {
          type: Boolean,
          value: false
        }
      },

      observers: [
        '_watchAll(type, idParam)'
      ],

      _watchAll: function(type, idParam) {
        let that = this;
        //Disconnect current event hub
        if (this.connection !== null && this.connection !== undefined) {
          this.connection.disconnect();
          this.connection = null;
        }
        //Create new connection
        this.connection = EventHub.connect();

        //Listen for object changes
        this.connection.on(this.eventHubName, function(data) {
          //Check that we care about this type
          if (data.type === type && data.object !== undefined && data.object != null) {
            //Get object id
            let id = data.object[idParam];
              //Add to internal array if not already in array
              for (let i = 0; i < that.get("_internalArray").length; i++) {
                if (that.get(["_internalArray", i, idParam]) === id) {
                  //Found the same object, just apply the changes
                  if(that.get(["_internalArray", i, "_nextChangeSignature"]) !== data.object._nextChangeSignature) {
                    that.set(["_internalArray", i], data.object);
                  }
                  return;
                }
              }
              that.push('_internalArray', data.object);
          }
        });
      },
      
      //Used for selecting idParam
      _arraySelector: function(array, index) {
        return array[index];
      },
      
      //Request all nodes with data on this object type to transmit it
      requestData: function() {
        EventHub.emit("ObjectRequest", this.type);
      }
    });
  </script>
</dom-module>